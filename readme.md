# 华为C++机试
# [**String** ](https://blog.csdn.net/qq_37941471/article/details/82107077)
## 1.string 与 int 转换  
- ### int 转 string

```cpp
to_string()
string = int + ""
```
- ### string 转 int

```cpp
 //1.
 int num = atoi(str.c_str());  //首字符为数字则返回数字，非数字则返回0，atoi的参数必须为const char*，另有atof()和atol()
 //2.
 int num = str-'0';
```
## 2.string类型的字符串长度获取的三种方法
```cpp
size(),length(),strlen()
```
## 3.输入含空格的字符串
```cpp
  scanf("%[a-z A-Z0-9]",str)  
  getline(cin, str)  //包含头文件<string>
  cin.get (char *str, int maxnum)
  cin.getline (char *str, int maxnum)
```
## 4.string划分与删除字符
- 划分字符串（按';'）
```cpp
  string str;
  cin>>str;
  int n = str.size();
  for (int i = 0; i < n; ++i){
      if (str[i] == ';'){
          str[i] = ' ';
      }
  }
  istringstream out(str);  //初始化out为str
  string mov[n];
  int temp  = 0;
  while (out >> mov[temp])
      temp++;
  //strtok
  //功能：来将字符串分割成一个个片段。当strtok()在参数s的字符串中发现参数delim中包含的分割字符时,则会将该字符改为\0 字符，当连续出现多个时只替换第一个为\0。返回分割后字符串首地址，改变原字符串。
  char *strtok(char *str, const char *delim);
  char sentence[]="This is a sentence with 7 tokens";
  cout << "The string to be tokenized is:\n" << sentence << "\n\nThe tokens are:\n\n";
  char *tokenPtr=strtok(sentence," ");
  while(tokenPtr!=NULL)　{
      cout<<tokenPtr<<endl;
      tokenPtr=strtok(NULL," ");
  }
  //cout << "After strtok,sentence=" << tokenPtr<<endl;

``` 
- 获取字符串的一段
```c
  string a = s.substr(0,5);  //获得字符串s中从第0位开始的长度为5的字符串
```
- 删除某个字符
```c
  string str;
  string target;
  int pos = str.find(target);
  n = target.size();
  str = str.erase(pos,n);  //从pos这个位置开始删除n个字符，后边的字符自动向前覆盖
```
## 5.判断字符串中是否含有某个子串
```c
  idx=a.find(b);  //如果存在，返回起始位置。不存在则返回 string::npos
  strstr(a.c_str(), b.c_str())  //char * strstr(const char *str1, const char *str2);
```
## 6.查找字符在字符串中首次出现的位置
  ```c  
    //strchr() 用来查找某字符在字符串中首次出现的位置，其原型为：
    char * strchr (const char *str, char c);
  ```
## 7.字符串拼接
```c
  strcat(str,ptr);  //将字符串ptr内容连接到字符串str后
```
## 8.strcpy()和strcpy_s
```cpp
// strcpy()函数和安全版本strcpy_s()函数都是存在于头文件<cstring>中
// strcpy()函数是存在于标准名称空间std中的成员
strcpy_s( 
char *strDestination, 
size_t numberOfElements, //一般为strSource的长度加1，这个1为字符串结尾的空字符
const char *strSource 
);
```
# **指针**
### 1.[指针传参](https://www.cnblogs.com/oddcat/articles/9773035.html)
  ```cpp
  int num;
  int *p = &num;
  fun1(int *p);
  fun1(p);  // 在函数内给*p赋值，外层*p会变，但若在函数内给p赋值，外层p不会变；
  fun2(int **p);
  fun2(&p);  // 向*p赋值改变指向值，向p赋值改变p指针的值
  ```
### 2.避免野指针
  - 1)凡是定义的指针变量初始化为NULL;
    2)指针 p 被 free 或者 delete 之后将其值赋为NULL;
    ```cpp
      delete []p;
      p=NULL;
    ```
# **内存管理**
### 1.delete和delete[]
```cpp
  delete a; // 释放new分配的单个对象指针指向的内存,分配简单类型数组内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数，它直接通过指针可以获取实际分配的内存空间
  delete[] a; // 释放new分配的对象数组指针指向的内存
```
### 2.New的使用
#### 2.1使用new建立动态数组
```c
  int num;
  cin>>num;
  int *index = new int[num];

  //用new创建一个二维数组   
  //1.
  int (*p)[line] = new int[row][line];   
  //删除二维数组：
  delete []p;
  int **p 

  //2.
  p = new int*[row];
  for(int i = 0;i < row; i++)
    p[i] = new int[line];
  //删除二维数组
  for(int i=0;i<row;i++)
    delete [] p[i];
  delete [] p;
```
### 3.深浅拷贝
  - 浅拷贝
  浅拷贝又称值拷贝，其实就是将原对象的值拷贝到目标对象中去，两者公用同一个实体，虽然名字不一样，但是用的地址是相同的。比如：
  有一个String类
  String a1;
  String a2(a1);
  将a1的值全部拷贝到a2中去（该操作为浅拷贝）。

  - 浅拷贝出现的问题，由于两者指向的是同一块内存，在程序结束时，先是调用a2析构函数，使得a2指向的内存得以释放，接着调用a1的析构函数，这个时候系统想释放a1指向的内存，由于a1a2指向的是同一块内存，而a2析构函数刚已经将该块内存释放了，系统试图重复释放同一块内存，就会出现崩溃。

  - 深拷贝
  深拷贝就是在拷贝时开辟一块和原对象一样大小的内存，然后将原对象中的值拷贝到开辟的内存中去，这样原对象和目标对象分别指向各自内存，然后值也一样，达到了我们的预期，在释放的时候也分别释放自己的内存 ，不会出现重复释放的情况。


# **输入输出**
### 1.sscanf
  - sscanf的作用：从一个字符串中读进于指定格式相符的数据。利用它可以从字符串中取出整数、浮点数和字符串。sscanf和scanf的区别：scanf是以键盘作为输入源，sscanf是以字符串作为输入源。
```cpp
  //取指定长度的字符串
  sscanf("12345","%4s",str);
  //格式化时间
  sscanf("2013/02/13 14:55:34","%d/%d/%d %d:%d:%d",&year, &month, &day, &hour, &minute, &second);
  // 取到指定字符为止的字符串。如例子所示，遇到‘+’为止的字符串。
  sscanf("1234+abc","%[^+]",str); // 打印1234
  sscanf("1234+abc1234","%[^a-z]",str); //遇到小写字母为止，打印1234+
  sscanf("123456abcdefBFRGTY7890","%[1-9a-z]",str); //取仅包含数字和小写字母的字符串，打印123456abcdef

```

# **类**
### 1.this
- 指向调用函数的实例的指针。
### 2.成员函数后面的:与&
```cpp
    ":"
    1、c++成员函数后面跟":"表示的是赋值，这是c++的特性

    A( int aa, int bb ):a(aa),b(bb)
    {
    }
    相当于
    A( int aa, int bb )
    {
    a=aa;
    b=bb;
    }
    2、c++构造函数后面跟“：”也表示赋值

    1）对含有对象成员的对象进行初始化

    类line有两个私有对象成员startpoint、endpoint,line的构造函数写成： 
    line（int sx,int sy,int ex,int ey）：startpoint（sx,sy），endpoint（ex,ey）{……} 

    2）对于不含对象成员的对象，初始化时也可以套用上面的格式，例如， 
    类rectangle有两个数据成员length、width,其构造函数写成： 
    rectangle（）：length（1），width（2）{} 
    rectangle（int x,int y）：length（x），width（y）{} 
    3）对父类进行初始化，例如， 
    CDlgCalcDlg的父类是MFC类CDialog,其构造函数写为： 
    CDlgCalcDlg（CWnd* pParent ）： CDialog（CDlgCalcDlg::IDD, pParent）

    "&"
    [引用限定符](http://en.savefrom.net/)
    [右值引用](https://www.jianshu.com/p/d19fc8447eaa)
```
# **函数** 
### void形参
```cpp
a(){cout<<"book";}
a(void){cout<<"book";}// void参数表示没有参数的意思，和（）表示的意思是一样的
a(void *){......}// void * 表示有一个指针类型的参数，无论是什么类型的指针，只要是指针就可以
```
------------------
# **STL**
## ***1. 迭代器***
```cpp
vector<int>::iterator iter=ivec.bengin();  //将迭代器iter初始化为指向ivec容器的第一个元素
``` 
## ***2. [vector](https://blog.csdn.net/qq_30534935/article/details/82353068)***
 ### 2.1 创建vector对象
  ```c
    vector<int> vec;  //声明一个int型向量
    vector<int> vec(8); //声明一个初始大小为8的int型向量
    vector<int> vec(10, -1) //声明一个初始大小为10且值都是-1的int型向量
  ```
  ### 2.2 vector赋值与修改
  ```cpp
  //赋值
    vec.assign(v1.begin(), v1.begin()+8);  //将动态数组v1的[v1.begin,v1.begin()+8)赋值给动态数组vec
    //修改
    auto &val = vec.back(); //val为指向最后一个元素的引用  
    val = 2;  //vector需要使用引用修改，不可以使用数组下标直接修改
  ```
  ### 2.3 vector访问
  ```cpp
    //通过下标访问、修改向量元素，但不可以通过下标添加元素
    for(int i = 0; i < vec.size(); i++){
        cout << vec[i];
    }
    //通过迭代器访问数组
    for(vector<int>::iterator iter = vec.begin(); iter != vec.end(); iter++){
        cout << *iter;
    }
    //通过指针访问数组
    int *p = vec.data();
    for (int i = 0; i < 5; i++){
      cout << *p++;
    }
  ```
  ### 2.4 添加元素
  ```cpp
    vec.push_back(p);  //在数组vec的末尾添加元素p
    vec.insert(v.it,p);  //在数组vec.it指向位置插入元素p
    vec.insert(v.it,n,p);  //在数组vec.it指向位置插入n个元素p
  ```
  ### 2.5 删除元素与删除重复元素
  ```cpp
    v.pop_back();  //删除数组v末尾的元素
    v.erase(ite);  //删除数组ite指向位置的元素,**并返回下一个迭代器，向前覆盖**
    for(ite=iVec.begin();ite!=iVec.end();) {
  　　if(*it==4 || *ite==5)
  　　　　ite=iVec.erase(ite);
      else
  　　　　ite++;
    }
    //删除重复元素
    sort(vec.begin(), vec.end());  //unique只移除相邻的重复元素所以需要先排序
    vector<int>::iterator ite = unique(vec.begin(), vec.end());  //unique将重复的元素移到末尾，返回末尾中第一个重复值的地址
    vec.erase(ite, vec.end());  //删除残余元素
  ```
  ### 2.6 反转reverse()
  ```cpp
  reverse(beg,end);
  reverse_copy(sourceBeg,sourceEnd,destBeg);
  //reverse()会将区间[beg,end)内的元素全部逆序；
  //reverse_copy()会将源区间[sourceBeg,sourceEnd)内的元素复制到
  //"以destBeg起始的目标区间"，并在复制过程中颠倒安置次序.
  ```
  ### 2.7 排序
  ```cpp
    vector<int> v{ 0, 3, 5, 7, 8, 1, 4, 9, 2, 6};
    //默认情况下升序排列
    sort(v.begin(), v.end()); // v{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    //可自定义排序方式（此为降序）
    bool Comp(const int &a, const int &b){
      return a>b;
    }
    sort(v.begin(), v.end(), Comp); // v{ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
    //亦可函数内部自定义 
    sort(v.begin(), v.end(), [](int &a, int &b){return a>b;});  // v{ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
    //sort给数组a[20]排序sort(a, a+20);
  ```

  ### 2.8 查找

  ```cpp
  // 第一种方法
　  vector<string>::iterator iter;
　　string gpcode="SZ000001";
　　iter = find(vec.begin(), vec.end(), gpcode);
　　if(iter != vec.end()){
　　　　//vec中存在"SZ000001"
　　}
　　else{
　　　　//没找到
　　}
  // 注意：如果vector中保存的是自定义类型（结构体/类），则需要为该类型重载==操作符。再用find
  // 第二种方法，包含头文件<algorithm>
    vector<string> vStr;
    int nRet = std::count(vStr.begin(), vStr.end(), "xiaochun");//判断vector中是否有 "xiaochun" 这个元素
  ```
  ### 2.9 vector和set的区别
  - STL中的容器可以分为两大类：
  1、顺序容器：list，queue，vector
  2、关联容器：map，set（当然对应的有multimap，multiset）
  其中vector的存储结构是数组，其它的存储结构是链表。
  言归正传，现在看一下vector和set的区别：
  首先vector属于顺序容器，其元素与存储位置与操作操作有关；set属于关联容器，其元素相当于键值。set能够保证它里面所有的元素都是不重复的（multiset除外）。
  其次，由于存储结构不同，vector擅长于解决某个位置是什么值的问题，而set擅长于解决，某个元素在那个位置的问题，知道元素的内容，查找它的位置。因此vector特别好的支持随机访问，而set不支持（不支持下标访问）。
## ***3. map***
  ### 3.1 pair类型的定义和初始化
    pair类型包含了两个数据值，通常有以下的一些定义和初始化的一些方法：

    pair<T1, T2> p; ： 定义了一个空的pair对象p，T1和T2的成员都进行了值初始化
    pair<T1, T2> p(v1, v2); ： p是一个成员类型为T1和T2的pair; first和second成员分别用v1和v2进行初始化。
    pair<T1, T2> p = {v1, v2} ：等价于p(v1, v2)
    make_pair(v1, v2) ： 以v1和v2值创建的一个新的pair对象
  ### 3.2 创建map对象
    map是键-值对的组合，即map的元素是pair，其有以下的一些定义的方法：

    map<k, v> m;	： 定义了一个名为m的空的map对象
    map<k, v> m2(m); ： 创建了m的副本m2
    map<k, v> m3(m.begin(), m.end()); ： 创建了map对象m3，并且存储迭代器范围内的所有元素的副本
 ### 3.3 map元素访问 
    - mymap['a'] = "an element";
    - mymap.at('a') = "an element";

  ### 3.4 map中元素的插入
  ```cpp
    //3.4.1 使用下标[]插入
    mymap[0] = 'a';
    //3.4.2 使用insert()插入元素
    // （1）插入单个值
    mymap.insert(std::pair<char, int>('a', 100));
    // （2）指定位置插入
    std::map<char, int>::iterator it = mymap.begin();
    mymap.insert(it, std::pair<char, int>('b', 300));
    // （3）范围多值插入
    std::map<char, int> anothermap;
    anothermap.insert(mymap.begin(), mymap.find('c'));
  ```
  ### 3.5 map删除元素
  ```cpp
    // erase() 删除元素 
    mymap.erase(0);          	 // （1）删除key为0的元素
    mymap.erase(mymap.begin());  // （2）删除迭代器指向的位置元素
    // 查找关键字1在容器map中出现的次数，如果不存在则为0
    mymap.count(1);
    // find()若存在，返回指向该key的迭代器
    // 若不存在，则返回迭代器的尾指针，即 mymap.end()，即 -1
    map<int, int>::iterator it_find;
    it_find = mp.find(0);
    //equal_range() 返回一个迭代器pair，表示关键字 == k的元素的范围。
    //若k不存在，pair的两个成员均等于c.end()
    //lower_bound()/upper_bound()函数需要加载头文件#include<algorithm>,
    //其基本用途是查找有序区间中第一个大于或等于/大于某给定值的元素的位置，
    //其中排序规则可以通过二元关系来表示。
    //rbegin() 返回一个指向map尾部的逆向迭代器
    //rend() 返回一个指向map头部的逆向迭代器
    //key_comp() 比较key_type值大小
    //value_comp() 比较value_type值大小
  ```
  ### 3.6 两种遍历方式
  ```cpp
      for (map<int, char>::iterator iter = mymap.begin(); iter != mymap.end(); iter++)
      cout << iter->first << " ==> " << iter->second << endl;
  ```
  ```cpp
      for (auto& x : mymap) {
          std::cout << x.first << ": " << x.second << '\n';
      }
  ```
  ### 3.7 map排序
  #### 3.7.1 map转vector
  ```cpp
  vector<pair<int, float> > map_vec(map.begin(), map.end());
  ```
  #### 3.7.2 对vector排序
  ```cpp
     sort(vect.begin(), vect.end());
  ```
  #### 3.7.3 map按value排序
  ```cpp
    typedef pair<string, int> PAIR;
    bool cmp_by_value(const PAIR& lhs, const PAIR& rhs) {  
      return lhs.second < rhs.second;  
    }
    //函数对象法
    struct CmpByValue {
      bool operator()(const PAIR& lhs, const PAIR& rhs) {
        return lhs.second < rhs.second;
      }
    };  
    vector<PAIR> name_score_vec(name_score_map.begin(), name_score_map.end();  
    sort(name_score_vec.begin(), name_score_vec.end(), CmpByValue()); 
  ```
## ***4. stack&queue***
  ```cpp
    push();  //进容器
    pop();  //出容器，没有返回值
    //取栈顶/对头元素，并没有删除元素
    top()/front();
    my2.swap(mystack);  //swap函数可以交换两个栈的元素
  ```
-------------------

# **经典问题**  
## 动态规划
  - [经典动态规划](https://blog.csdn.net/ailaojie/article/details/83014821) 
--------
## 回溯算法
---------
## 贪心算法
--------------
## 分治算法
------------------
## 分支界限算法
------------
## 01背包问题

-------------------

# **面试经验**  
## const
#### const指针，顶层const，底层const
- 作用
1 执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const。
2 使用命名的强制类型转换函数const_cast时，需要能够分辨底层const和顶层const，因为const_cast只能改变运算对象的底层const。
```cpp
  const double pi = 3.14; // pi是一个常量，不能改变它的值

  const double *cptr = &pi; //cptr指向pi,注意这里的const不能丢，因为普通指针不能指向常量对象，即，不能用非const变量初始化指向常量的指针.
  *cptr = 3.33;  //错误,试图改变所指对象的值。不能改变指针所指对象的值
  cout << cptr << endl；//输出cptr的值Kv
  //虽然不能改变其所指对象的值，但是它可以指向别的常量对象
  //这样的话 指针的值（也就是存放在指针中的那个地址）也会改变

　int const *a; 　//或const int* a，a可变，*a不可变，指向const int的常量指针，底层const
　int *const a; 　//a不可变，*a可变 ，指向int的指针常量，顶层const
  //分析：const 是个左结合的类型修饰符，他和其左侧的类型修饰符和为一个类型修饰符，所以，int const 限定 *a,不限定a。int *const 限定a,不限定*a。
```
#### const成员变量初始换
```cpp
  class foo{  
    public:  
          foo():i(100){}; // const成员变量不能在类的内部初始化，一般地是在构造函数中初始化
    private:  
          //const int i=100; //error!!!
          static int i;  
  };
  int foo::i=20; // static类静态成员变量同样不能在类的内部初始化
```
## static
    - 静态变量：
      static sta; //在函数中声明则不会随函数调用结束而销毁
    - 静态函数：
      1.静态函数不能被其它文件所用;
      2.其它文件中可以定义相同名字的函数，不会发生冲突;
    - 静态数据成员：
        用于修饰 class 的数据成员，即所谓“静态成员”。这种数据成员的生存期大于 class 的对象（实体 instance）。静态数据成员是每个 class 有一份，普通数据成员是每个 instance 有一份，因此静态数据成员也叫做类变量，而普通数据成员也叫做实例变量。
        static只会被初始化一次，于实例无关。
    - 静态成员函数：
        因为静态是属于类的，所以静态成员函数不能访问非静态(包括成员函数和数据成员)，但是非静态可以访问静态

## volatile
    volatile关键字是一种限定符用来声明一个对象在程序中可以被语句外的东西修改,比如操作系统、硬件或并发执行线程。
    遇到该关键字，编译器不再对该变量的代码进行优化，不再从寄存器中读取变量的值，而是直接从它所在的内存中读取值，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
    当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。


## 堆栈
    - 对于一个完整的程序，在内存中的分布情况如下图：　 
    1.栈区： 由编译器自动分配释放，像局部变量，函数参数，都是在栈区。会随着作用于退出而释放空间。
    2.堆区：程序员分配并释放的区域，像malloc(c),new(c++) 
    3.全局数据区(静态区)：全局变量和静态便令的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束释放。
    //栈溢出问题
    可以使用命令调整栈的大小改善栈溢出问题。
    #pragma comment(linker,"/STACK:102400000,1024000")  //将堆栈改变为100M
    第一个值是堆栈的保留空间，第二个值是堆栈开始时提交的物理内存大小。
    - 管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。
    - 空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：   
    打开工程，依次操作菜单如下：Project->Setting->Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。
    注意：reserve最小值为4Byte；commit是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。
    - 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。
    - 生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。
    分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。
    - 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。
## union和enum
    1.union类型可以出现在结构体类型定义中，也可以定义union数组，反之，结构体也可以出现在union类型定义中，数组也可以作为union的成员；
    2.由于union中的所有成员起始地址都是一样的，所以&a.mark、&a.num和&a.score的值都是一样的；
    3.union中可以含有类，但是类要求为c风格，即不可以有构造函数会析构函数等，由于union里面的东西共享内存，所以不能定义静态、引用类型的变量。
## 内联函数与宏
    函数有一个潜在的缺点：调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行
    C++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 inline 放在函数定义(注意是定义而非声明，下文继续讲到)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开，假设我们将 max 定义为内联函数：
    
      inline int max(int a, int b){
          return a > b ? a : b;
      }
      
    则调用： cout << max(a, b) << endl; 
    在编译时展开为： cout << (a > b ? a : b) << endl;  从而消除了把 max写成函数的额外执行开销。

    - 内联函数和宏：
      1、宏容易出错；
      2、宏不可调试；
      3、宏无法操作类的私有对象；
      4、内联函数可以更加深入的优化；

    - 定义在类声明之中的成员函数将自动地成为内联函数。

    - 内联函数的调用要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：
      （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
      （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。
## 多态、重载、重写、动态绑定与虚机制
  **只有虚函数才使用的是动态绑定，其他的全部是静态绑定。**
  ```cpp
    class B{
        void DoSomething();
        virtual void vfun();
    }
    class C : public B{
        void DoSomething();//首先说明一下，这个子类重新定义了父类的no-virtual函数，这是一个不好的设计，会导致名称遮掩；这里只是为了说明动态绑定和静态绑定才这样使用。
        virtual void vfun();
    }
    class D : public B{
        void DoSomething();
        virtual void vfun();
    }
    D* pD = new D();
    B* pB = pD;
  ```
    - 让我们看一下，pD->DoSomething()和pB->DoSomething()调用的是同一个函数吗？
    不是的，虽然pD和pB都指向同一个对象。因为函数DoSomething是一个no-virtual函数，它是静态绑定的，也就是编译器会在编译期根据对象的静态类型来选择函数。pD的静态类型是D*，那么编译器在处理pD->DoSomething()的时候会将它指向D::DoSomething()。同理，pB的静态类型是B*，那pB->DoSomething()调用的就是B::DoSomething()。

    - 让我们再来看一下，pD->vfun()和pB->vfun()调用的是同一个函数吗？
    是的。因为vfun是一个虚函数，它动态绑定的，也就是说它绑定的是对象的动态类型，pB和pD虽然静态类型不同，但是他们同时指向一个对象，他们的动态类型是相同的，都是D*，所以，他们的调用的是同一个函数：D::vfun()。

    - 在继承中要构成多态还需要两个条件：
      a. 调用函数的对象必须是指针或者引用。
      b. 被调用的函数必须是虚函数，且完成了虚函数的重写。

    - 纯虚函数就是在虚函数后加了“=0”,而且在基类中没有任何实现，那么包含纯虚函数的类自然就被称为抽象类，抽象类是不能定义对象的，而在继承基类的子类中必须实现抽象类中的纯虚函数，否则也会出错，抽象类虽然不能定义对象，但是可以定义指针。
------------




## 内存对齐
  - 所谓内存对齐，是为了让内存存取更有效率而采用的一种编译阶段优化内存存取的手段。
  比如对于int x;（这里假设sizeof(int)==4），因为cpu对内存的读取操作是对齐的，如果x的地址不是4的倍数，那么读取这个x，需要读取两次共8个字节，然后还要将其拼接成一个int，这比存取对齐过的x要麻烦很多。（比如操作系统一次允许读4个字节，从内存4-7存放的是一个int，此时如果从地址4开始读，恰好可以读出一个int，但是如果从地址3开始读，需要读两次，然后进行拼接，形成一个int）。
  - 结构体的大小：在默认情况下，VC规定各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数。并且：VC为了确保结构的大小为结构的字节边界数（即该结构中占用最大空间的类型所占用的字节数）的倍数，所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节。
  - ```cpp
      struct MyStruct{
        double dda1;
        char dda;
        int type;
      };// sizeof(MyStruct)=8+1+3（自动填充）+4=16
    ```
-----------



## malloc与free
### malloc
  - 从操作系统角度来看，进程分配内存有2种方式，分别由2个系统调用完成：brk和mmap（不考虑共享内存）。
  1.brk是将数据段(.data)的最高地址指针_edata往高地址推
  2.mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。
  这两种方式分配的**都**是虚拟内存，**没有分配物理内存**。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。
  - malloc小于128k的内存，使用brk分配内存，将_edata往高地址推,_edata指针（glibc里面定义）指向数据段的最高地址;
  malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。
  你可能会问：只要把_edata+30K就完成内存分配了？
  事实是这样的，_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的
  ![malloc<128k](D:/STUDY/2016215233hfut/c/git_test/pic/20171017215810378.jpg)
  - malloc**大于128k**的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，如下图：
  ![malloc<128k](D:/STUDY/2016215233hfut/c/git_test/pic/20171017215827877.jpg)
  默认情况下，malloc函数分配内存，如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。这样子做主要是因为:brk分配的内存需要等到高地址内存释放以后才能释放（例如，**在B释放之前，A是不可能释放的**，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。
  - **内存紧缩操作（trim）**
  默认情况下：当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图9所示。
  ![free_trim](D:/STUDY/2016215233hfut/c/git_test/pic/20171017215837253.jpg)
### free
  - malloc()申请内存时需要指定申请多大的内存空间，为什么free()释放内存时只需要传递一个指针而不需要指定释放多大的内存空间:
  在内存首地址**前16个字节**处存放了申请内存块大小的数值,Windows里面当我们使用free函数释放内存的时候，函数会把内存块的首地址加上16，从这个位置就可以找到内存块的大小。
----------------------



## float比较大小
  - float 类型不能比较相等或不等，但可以比较> , <,> =, <=
    用\=\=从语法上说没错，但是本来应该相等的两个浮点数由于计算机内部表示的原因可能略有微小的误差，这时用==就会认为它们不等。应该使用**两个浮点数之间的差异的绝对值小于某个可以接受的值**来判断判断它们是否相等,比如用
    if (fabs(price - p) < 0.000001) // fabs求float的绝对值，abs求int的绝对值
    来代替
    if (price == p)
  - 还有一种方法就是**扩大再取整**，比如 a=5.23、b=5.23，直接比较 a==b 有可能为 false，但是 a 和 b 都扩大一百倍，然后强制转换为 int 类型，再用 == 比较就可以了。
---------------------






## 进程与线程
### 多进程与多线程
  - **多进程**
  进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。
  Linux系统函数fork()可以在父进程中创建一个子进程，这样的话，在一个进程接到来自客户端新的请求时就可以复制出一个子进程让其来处理，父进程只需负责监控请求的到来，然后创建子进程让其去处理，这样就能做到并发处理。
  - **多线程**
  线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。
  - **线程和进程各自有什么区别和优劣呢？**
  进程是资源分配的最小单位，线程是程序执行的最小单位。
  进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
  线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
  但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。
### 进程间通信方式
  - 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
  - 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
  - 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
  - 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
  - 以上几种进程间通信方式中，消息队列是使用的比较频繁的方式。
  - Queue和pipe只是实现了数据交互，并没实现数据共享，即一个进程去更改另一个进程的数据。
  注：进程间通信应该尽量避免使用共享数据的方式
### [线程锁与同步](https://blog.csdn.net/bian_qing_quan11/article/details/73734157)
  - 最常见的进程/线程的同步方法有**互斥锁**（或称互斥量Mutex)，**读写锁**(rdlock)，**条件变量**(cond)，**信号量**(Semophore)等，在Windows系统中，临界区（Critical Section）和事件对象(Event)也是常用的同步方法。线程之间的锁有：**互斥锁、条件锁、自旋锁、读写锁、递归锁**。一般而言，锁的功能越强大，性能就会越低。
  - 使用**条件变量**的一个经典的例子就是线程池(Thread Pool)。
  - **互斥锁**：用于控制多个线程对他们之间共享资源互斥访问的一个信号量。可以避免多个线程在某一时刻同时操作一个共享资源，标准C++库提供了std::unique_lock类模板，实现了互斥锁的RAII惯用语法：任何是一个线程都要使用互斥锁互斥访问任务队列，以避免多个线程同时访问任务队列以发生错乱。
  - **条件锁**：条件锁就是所谓的条件变量，某一个线程因为某个条件未满足时可以使用条件变量使该程序处于阻塞状态。一旦条件满足了，即可唤醒该线程(常和互斥锁配合使用)，唤醒后，需要检查变量，避免虚假唤醒。
  - **自旋锁**：当线程等待自旋锁的时候，CPU不能做其他事情，而是一直处于轮询忙等的状态。自旋锁主要适用于被持有时间短，线程不希望在重新调度上花过多时间的情况。
  - **读写锁**：允许在数据库上同时执行多个“读”操作，但是某一时刻只能在数据库上有一个“写”操作来更新数据。
  - **递归锁**：Mutex可以分为递归锁(recursive mutex)和非递归锁(non-recursive mutex)。可递归锁也可称为可重入锁(reentrant mutex)，非递归锁又叫不可重入锁(non-reentrant mutex)。二者唯一的区别是，同一个线程可以多次获取同一个递归锁，不会产生死锁。而如果一个线程多次获取同一个非递归锁，则会产生死锁。刚开始引用锁的时候，就产生它，当在锁没有解开的时候，还要继续用锁，就简单的加一，解开一把就减一，当计数为零时，就把锁销毁掉。
### 上下文切换
  - 上下文切换（有时也称做进程切换或任务切换）是指CPU从一个进程或线程切换到另一个进程或线程。
    - **进程**（有时候也称做任务）是指一个**程序运行的实例**。
  - 上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动：
    - 挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处；
    - 恢复一个进程，在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复；
    - 跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。

  **切换种类**
  - 上下文切换在不同的场合有不同的含义，在下表中列出：

  | 上下文切换种类| 描述  |
  | -------| :--------------- |
  | 线程切换   | 	同一进程中的两个线程之间的切换  |
  | 进程切换 | 两个进程之间的切换 | 
  | 模式切换 | 在给定线程中，用户模式和内核模式的切换  | 
  | 地址空间切换	 | 将虚拟内存切换到物理内存  |

  **上下文切换的内容/步骤**
  - 线程切换和进程切换的步骤也不同。进程的上下文切换分为两步：
    - **切换页目录以使用新的地址空间；**
    - **切换内核栈和硬件上下文；**
  - 对于Linux来说，线程和进程的最大区别就在于地址空间。**对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的**。所以明显是进程切换代价大。线程上下文切换和进程上下文切换一个最主要的区别是**线程的切换虚拟内存空间依然是相同的**，但是进程切换是不同的。

  **减少切换**
  - **让步式上下文切换**：指执行线程主动释放CPU，与锁竞争严重程度成正比，可通过减少锁竞争来避免；
  - **抢占式上下文切换**：指线程因分配的时间片用尽而被迫放弃CPU或者被其他优先级更高的线程所抢占，一般由于线程数大于CPU可用核心数引起，可通过调整线程数，适当减少线程数来避免。
  ----------------------------



## HTTP协议
  - **HTTPS协议 = HTTP协议 + SSL/TLS协议**，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL/TLS一起合作完成的。
### 常用方法
#### GET
  - GET是最常用的方法，通常用于请求服务器发送某个资源。HTTP/1.1 要求服务器实现该方法。下图为客户端用GET方法发起一次HTTP请求。
#### HEAD
  - HEAD方法和GET方法的行为很类似，但是服务器在响应中只返回首部，不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。
    使用HEAD方法有以下优点：

    - 在不获取资源的情况下了解资源的情况（比如：判断其类型）；
    - 通过查看响应的状态码，看看某个对象是否存在；
    - 通过查看首部，测试资源是否被修改了
  必须确保返回的首部与GET请求所返回的首部完全相同，遵循HTTP/1.1规范，就必须实现HEAD方法。下图为HEAD方法的实际用法
#### PUT
  - 与GET从服务器读取文档想法，PUT方法会向服务器写入文档。PUT方法的语义就是让服务器用请求的主体部分来创建一个由所请求的URL命名的新闻的，或者替换已存在的URL。具体使用方法如下：
  ![PUT](/pic/HTTP_PUT.png)
  因为PUT允许用户对内容进行修改，所以很多Web服务器都要求在执行PUT之前，用密码登录。
#### POST
  - POST方法期初是用来向服务器输入数据的，实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方。
 #### GET和POST的区别：
  - 1、GET请求的数据是放在HTTP包头中的，也就是URL之后，通常是像下面这样定义格式的：
  login.action?name=hyddd&password=idontknow&verify=%E4%BD%E5%A5%BD
  其中，**以?来分隔URL和数据；以&来分隔参数**；如果数据是英文或数字，原样发送；**如果数据是中文或其它字符，则进行BASE64编码**。
  而Post是把提交的数据放在**HTTP正文中**的。
  - 2、GET提交的数据比较少，~~最多1024B~~，因为GET数据是附在URL之后的，而URL则会受到不同环境的限制的，比如说IE对其限制为2K+35，而POST可以传送更多的数据（理论上是没有限制的，但一般也会受不同的环境，如浏览器、操作系统、服务器处理能力等限制，IIS4可支持80KB，IIS5可支持100KB）。
  - 3、Post的安全性要比Get高，因为Get时，参数数据是明文传输的，参数直接暴露在url中，所以不能用来传递敏感信息。而且使用GET的话，还可能造成Cross-site request forgery攻击。而POST数据则可以加密的，但GET的速度可能会快些。
  - 4、get请求只能进行url编码，而post支持多种编码方式；get请求会浏览器主动cache，而post支持多种编码方式；get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。
  - 5、GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
  - 6、GET产生一个TCP数据包；**POST产生两个TCP数据包**。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
#### TRACE
  - 客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或者其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成什么样子了。
  TRACE请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP应用程序组成的请求/响应链上，原始报文是否被毁坏，以及如何被毁坏或修改过。
  ![OPTOINS](/pic/HTTP_TRACE.png)
#### OPTIONS
  - OPTIONS方法请求Web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支撑哪些方法。（有些服务器可能只支持对一些特殊类型的对象使用特定的操作）
  ![OPTOINS](/pic/HTTP_OPTIONS.png)
#### DELETE
  - DELETE方法所做的事情就是请服务器删除请求URL所指定的资源,对应PUT方法。但客户端应用程序无法保证删除操作一定会被执行。因为HTTP规范允许服务器 在不通知客户端的情况下撤销请求。
### [状态码](https://blog.csdn.net/vikeyyyy/article/details/80665945)
#### 100~199——信息行状态码
| 状态码| 原因短语    |  含义  |
| --------------------| :--------------- | :---------- |
| 100   | 	Continue  | 请求没问题，实体的主体部分包含了所请求的资源。|
| 101   | 	Switching Protocols  | 用于创建服务器对象的请求（比如：PUT）。响应的实体主体部分中应该包含各种引用了已创建的资源的URL，Location首部包含的则是最具体的引用。|
#### 200~299——成功状态码
| 状态码| 原因短语    |  含义  |
| --------------------| :--------------- | :---------- |
| 200   | 	OK  | 说明受到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在受到请求之后必须进行响应。|
| 201   | Created  | 说明服务器正在根据客户端的指定，将协议切换成Update首部所列的协议。|
| 202   | Accepted  | 请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求，这只是意味着接受请求时，它看起来是有效的。服务器应该在实体的主体部分包含对请求状态的描述，或许还应该有对请求完成时间的估计。|
#### 300~399——重定向状态码
  - 重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是客户的资源内容。如果资源已被移动了，可发送一个重定向状态码和一个可选的Location首部来告知客户端资源已被移走，以及现在可以在哪里找。这样浏览器就能在不打扰使用者的情况下，透明地转入新位置。
  ![OPTOINS](/pic/HTTP_CODE_REDIRECT.png)
#### 400~499——客户端错误状态码
#### 500~599——服务器错误状态码
### 对称加密与非对称加密
  - **对称加密**：对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。
  其加密过程如下：**明文 + 加密算法 + 私钥 => 密文**
  解密过程如下： **密文 + 解密算法 + 私钥 => 明文**
  - **非对称加密**：非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。
  被公钥加密过的密文只能被私钥解密，过程如下：
  **明文 + 加密算法 + 公钥 => 密文， 密文 + 解密算法 + 私钥 => 明文**
  被私钥加密过的密文只能被公钥解密，过程如下：
  **明文 + 加密算法 + 私钥 => 密文， 密文 + 解密算法 + 公钥 => 明文**
## 在main函数前执行的步骤
  - 程序执行前装载器会把用户的参数和环境变量压入栈，接着操作系统把控制权交给mainCRTStartup入口函数。
    用户的参数：对应**int main(int argc,char *argv[])**
    环境变量：系统公用数据，系统搜索路径等等；
  - 初始化堆；
  - 全局变量构造；
  - 静态变量初始化，非方法内的static变量初始化，方法内的static在第一次执行函数的时候初始化，并且只初始化一次；
  - ~~注册析构函数~~
  -----------------




## 内存布局
### 分布
  - 一个程序运行起来，操作系统会给每个进程分配一个 4G 的程序地址空间，当然这都是虚拟地址空间，因为如果一个进程分 4G 的内存，那么就算有再多的内存也不够分。
  ![MEMORY_LAYOUT](/pic/MEMORY_LAYOUT.png)
  - 一、首先进程地址空间的 1G 内核空间是给操作系统使用的，我们用户是没有操作权限的。
  二、剩下的 3G 内存空间中，分为了**栈区、内存映射段、堆区、数据段、bss段、代码段**；
  1）栈区：这里的栈和数据结构的栈并不相同，数据结构的栈是一种后进先出的数据结构，而内存划分的栈是操作系统按照栈的特性，给用户划分出的内存区间。
     栈区一般存放：**函数体的局部变量、函数调用期间的所有参数压栈、函数的返回值**；
  注意栈区这段内存是由操作系统自己维护的，所以函数结束，在栈上的空间会由操作系统自己回收。
  2）堆区：用户所操作的内存就是堆上的空间，用户可以使用 malloc / calloc / realloc / new 申请堆上的空间，但是用户申请堆上的空间必须自己**手动释放**，不然会造成内存泄漏。
  3）内存映射段：里面存放 动态库/静态库，以及文件映射，匿名映射等等一切有依赖性的东西都在这段区域
  4）一个程序本质上都是由**bss段、数据段、代码段**组成的
     数据段：存放**全局变量、静态类型的变量**。当代码编译完后，在可执行程序这个文件中已经把这些数据的空间划分好了，这种类型的数据，在程序运行以前，操作系统就将数据段中的数据加载到内存了。**也就是说在进入 main 函数之前这些数据已经划分号空间了**。
     bss段：其实在 C 语言中，数据段中还有一个 bss 段，**这里面存放的是未初始化的全局变量和静态数据**，而数据段中存放的是已经初始化过的全局变量和静态数据。数据段中的所有数据已经划分好空间了，但是 bss 段并没有给其中的数据划分空间。
     代码段：存放可执行代码，以及只读常量(字符串常量等等)。**这段内存是只读的**。
  ### 递归的极限
  - C++ 中的限制是由于堆栈的最大大小。 这通常比RAM的大小还要小一些，但仍然相当大。 ( 幸运的是，像 str 内容这样的大东西通常不在堆栈本身中。)
  堆栈限制在操作系统级别通常是可调的。 ( 如果你在unix上，请参阅 ulimit 外壳的文档。) 这里机器( OSX ) 上的默认值为 8 MB 。
## [动态库/静态库](https://www.cnblogs.com/skynet/p/3372855.html)
  - 库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。
  本质上来说库是一种**可执行代码的二进制形式**，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。
### 静态库
  - 之所以成为【静态库】，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。
  试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟.o文件格式相似。其实一个静态库可以简单看成是**一组目标文件（.o/.obj文件）的集合**，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：
    - 静态库对函数库的链接是放在**编译时期完成的**。
    - 程序在运行时与函数库再无瓜葛，移植方便。
    - 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。
### 动态库（共享库）
  - 动态库特点总结：
    - 动态库把对一些库函数的链接载入推迟到程序运行的时期。
    - 可以实现进程之间的资源共享。（因此动态库也称为共享库）
    - 将一些程序升级变得简单。
    - 甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）。
  - 静态库对程序的更新、部署和发布页会带来麻烦。如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，**全量更新**）。
  动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，**增量更新**。


编程题：
一个数组元素可能是int类型的，也可能是这个类型本身。用C++实现结构体，写个函数将这个结构体数组扁平化，就是转化为一维数组。

判断二叉树找根节点到叶子节点和为n的路径是否存在。

链表翻转，给定正整数k，每k个元素翻转一次，不足k则保持原样。（原地翻转）。

正则表示式匹配，模式串含有？和*。判断字符串是否匹配模式串。然后算时间复杂度，用dp优化，优化完再算时间复杂度...

基础问题：
C++虚函数实现。菱形继承虚函数实现？，多继承虚函数实现？
页表大小是多少？为什么？
你写过线程池吗?怎么实现的？当往任务队列中添加任务时，因为需要获得锁，所以不能及时将任务加入队列中，如何处理这个问题？
## C/C++常见报错
## gcc
  - gcc Demo.c -o Demo.exe：指令-o（小写）用来指定生成的文件名。
  - **预处理**阶段会把调用的头文件包含进来，替换宏常量和宏代码段。我们执行指令gcc -E Demo.c -o Demo.i并看看Demo.i文件中的代码。
  - 执行-S（大写）**编译**指令将*.i文件中源码转化为汇编代码*.s文件。我们执行指令gcc -S Demo.i -o Demo.s，在当前目录下将生成Demo.s文件，用记事本打开会发现c源码已经被编译器转化为汇编代码。
  - 执行-c（小写）**汇编**指令将*.s文件中的汇编源码转化未机器能执行的二进制机器码，生成文件*.o。执行指令gcc -c Demo.s -o Demo.o。
  - 经过汇编处理后生成的二进制文件Demo.o虽然已经机器码，但仍然无法运行因为少了链接操作。**链接**操作可执行指令gcc Demo.o -o Demo.exe
  - 直接运行：1.gcc main.c 2. ./main
## Linux相关
  ### [常见命令](https://blog.csdn.net/l18848956739/article/details/93859531)
  - grep -i "text":查询含有text的文件，不区分大小写；
  - top：总体的系统运行状态和cpu的使用率，dstat：每秒cpu使用率情况获取；
  - crontab -e：打开定时任务的编辑，和编辑文件一样；
  - 第一个字符表示文件类型，d是文件夹，l是连接文件，-是普通文件。后面的9个字符表示权限。权限分为4中，r表示读取权限，w表示写入权限，x表示执行权限，-表示无此权限；
  - ifconfig eth0 显示一个以太网卡的配置；
  - route -n show routing table；
  - host www.example.com 查找主机名以将名称解析为IP地址，反之亦然；
  ### [shell](https://www.cnblogs.com/istart/p/11157991.html)
  - chmod 761表示，给创建文件的用户设置的权限是7，7=4+2+1，所以意思是给创建文件的用户赋予读取，写入和执行权限。6=4+2，也就是说给创建文件的用户所在的组赋予读取和写入权限，最后一个1表示执行权限，也就是说，给其他用户执行权限。chmod +x test.sh，赋予执行权限；
  - echo：输出命令，使用echo 命令查看变量值：echo $A；
  - read：输入命令，read -p(提示语句) -n(字符个数) -t(等待时间，单位为秒) –s(隐藏输入)；
  - if[]; then(true) elif[]; then fi(false) done;
  - case index in file;
  - for index in file do done;
  - while true do done;